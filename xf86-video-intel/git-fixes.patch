diff --git a/src/Makefile.am b/src/Makefile.am
index b0a1cf7..7d823ce 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -49,6 +49,7 @@ intel_drv_la_SOURCES = \
          intel_driver.c \
          intel_driver.h \
          intel_memory.c \
+	 intel_shadow.c \
 	 intel_uxa.c \
          intel_video.c \
          intel_video.h \
diff --git a/src/common.h b/src/common.h
index f7e4923..6f23cdd 100644
--- a/src/common.h
+++ b/src/common.h
@@ -182,9 +182,10 @@ intel_host_bridge (void);
  * Compare to CREATE_PIXMAP_USAGE_* in the server.
  */
 enum {
-	INTEL_CREATE_PIXMAP_TILING_X = 0x10000000,
-	INTEL_CREATE_PIXMAP_TILING_Y,
-	INTEL_CREATE_PIXMAP_TILING_NONE,
+	INTEL_CREATE_PIXMAP_TILING_X	= 0x10000000,
+	INTEL_CREATE_PIXMAP_TILING_Y	= 0x20000000,
+	INTEL_CREATE_PIXMAP_TILING_NONE	= 0x40000000,
+	INTEL_CREATE_PIXMAP_DRI2	= 0x80000000,
 };
 
 #endif /* _INTEL_COMMON_H_ */
diff --git a/src/i830_render.c b/src/i830_render.c
index 4bc582c..52646d3 100644
--- a/src/i830_render.c
+++ b/src/i830_render.c
@@ -231,7 +231,7 @@ static uint32_t i8xx_get_card_format(intel_screen_private *intel,
 			return i830_tex_formats[i].card_fmt;
 	}
 
-	if (IS_I85X(intel) || IS_I865G(intel)) {
+	if (!(IS_I830(intel) || IS_845G(intel))) {
 		for (i = 0; i < sizeof(i855_tex_formats) / sizeof(i855_tex_formats[0]);
 		     i++) {
 			if (i855_tex_formats[i].fmt == picture->format)
diff --git a/src/i965_render.c b/src/i965_render.c
index 15fbe49..c0c5de4 100644
--- a/src/i965_render.c
+++ b/src/i965_render.c
@@ -912,7 +912,7 @@ static drm_intel_bo *gen4_create_wm_state(ScrnInfoPtr scrn,
 
 	wm_state->wm4.stats_enable = 1;	/* statistic */
 
-	if (IS_IGDNG(intel))
+	if (IS_GEN5(intel))
 		wm_state->wm4.sampler_count = 0;	/* hardware requirement */
 	else
 		wm_state->wm4.sampler_count = 1;	/* 1-4 samplers used */
@@ -946,7 +946,7 @@ static drm_intel_bo *gen4_create_wm_state(ScrnInfoPtr scrn,
 	/* binding table entry count is only used for prefetching, and it has to
 	 * be set 0 for IGDNG
 	 */
-	if (IS_IGDNG(intel))
+	if (IS_GEN5(intel))
 		wm_state->thread1.binding_table_entry_count = 0;
 
 	drm_intel_bo_unmap(wm_state_bo);
@@ -977,7 +977,7 @@ static drm_intel_bo *gen4_create_vs_unit_state(ScrnInfoPtr scrn)
 	memset(&vs_state, 0, sizeof(vs_state));
 
 	/* Set up the vertex shader to be disabled (passthrough) */
-	if (IS_IGDNG(intel))
+	if (IS_GEN5(intel))
 		vs_state.thread4.nr_urb_entries = URB_VS_ENTRIES >> 2;	/* hardware requirement */
 	else
 		vs_state.thread4.nr_urb_entries = URB_VS_ENTRIES;
@@ -1201,7 +1201,7 @@ static void i965_emit_composite_state(ScrnInfoPtr scrn)
 		OUT_BATCH(MI_FLUSH |
 			  MI_STATE_INSTRUCTION_CACHE_FLUSH |
 			  BRW_MI_GLOBAL_SNAPSHOT_RESET);
-		if (IS_G4X(intel) || IS_IGDNG(intel))
+		if (INTEL_INFO(intel)->gen >= 45)
 			OUT_BATCH(NEW_PIPELINE_SELECT | PIPELINE_SELECT_3D);
 		else
 			OUT_BATCH(BRW_PIPELINE_SELECT | PIPELINE_SELECT_3D);
@@ -1213,7 +1213,7 @@ static void i965_emit_composite_state(ScrnInfoPtr scrn)
 		/* Zero out the two base address registers so all offsets are
 		 * absolute.
 		 */
-		if (IS_IGDNG(intel)) {
+		if (IS_GEN5(intel)) {
 			OUT_BATCH(BRW_STATE_BASE_ADDRESS | 6);
 			OUT_BATCH(0 | BASE_ADDRESS_MODIFY);	/* Generate state base address */
 			OUT_BATCH(0 | BASE_ADDRESS_MODIFY);	/* Surface state base address */
@@ -1241,7 +1241,7 @@ static void i965_emit_composite_state(ScrnInfoPtr scrn)
 			  I915_GEM_DOMAIN_INSTRUCTION, 0, 0);
 	}
 
-	if (IS_IGDNG(intel)) {
+	if (IS_GEN5(intel)) {
 		/* Ironlake errata workaround: Before disabling the clipper,
 		 * you have to MI_FLUSH to get the pipeline idle.
 		 */
@@ -1252,7 +1252,7 @@ static void i965_emit_composite_state(ScrnInfoPtr scrn)
 		int pipe_ctrl;
 		/* Pipe control */
 
-		if (IS_IGDNG(intel))
+		if (IS_GEN5(intel))
 			pipe_ctrl = BRW_PIPE_CONTROL_NOWRITE;
 		else
 			pipe_ctrl =
@@ -1369,7 +1369,7 @@ static void i965_emit_composite_state(ScrnInfoPtr scrn)
 			w_component = BRW_VFCOMPONENT_STORE_SRC;
 		}
 
-		if (IS_IGDNG(intel)) {
+		if (IS_GEN5(intel)) {
 			/*
 			 * The reason to add this extra vertex element in the header is that
 			 * IGDNG has different vertex header definition and origin method to
@@ -1412,7 +1412,7 @@ static void i965_emit_composite_state(ScrnInfoPtr scrn)
 			  (BRW_SURFACEFORMAT_R32G32_FLOAT << VE0_FORMAT_SHIFT) |
 			  (0 << VE0_OFFSET_SHIFT));
 
-		if (IS_IGDNG(intel))
+		if (IS_GEN5(intel))
 			OUT_BATCH((BRW_VFCOMPONENT_STORE_SRC <<
 				   VE1_VFCOMPONENT_0_SHIFT) |
 				  (BRW_VFCOMPONENT_STORE_SRC <<
@@ -1434,7 +1434,7 @@ static void i965_emit_composite_state(ScrnInfoPtr scrn)
 		/* u0, v0, w0 */
 		OUT_BATCH((0 << VE0_VERTEX_BUFFER_INDEX_SHIFT) | VE0_VALID | (src_format << VE0_FORMAT_SHIFT) | ((2 * 4) << VE0_OFFSET_SHIFT));	/* offset vb in bytes */
 
-		if (IS_IGDNG(intel))
+		if (IS_GEN5(intel))
 			OUT_BATCH((BRW_VFCOMPONENT_STORE_SRC <<
 				   VE1_VFCOMPONENT_0_SHIFT) |
 				  (BRW_VFCOMPONENT_STORE_SRC <<
@@ -1448,7 +1448,7 @@ static void i965_emit_composite_state(ScrnInfoPtr scrn)
 		if (mask) {
 			OUT_BATCH((0 << VE0_VERTEX_BUFFER_INDEX_SHIFT) | VE0_VALID | (src_format << VE0_FORMAT_SHIFT) | (((2 + selem) * 4) << VE0_OFFSET_SHIFT));	/* vb offset in bytes */
 
-			if (IS_IGDNG(intel))
+			if (IS_GEN5(intel))
 				OUT_BATCH((BRW_VFCOMPONENT_STORE_SRC <<
 					   VE1_VFCOMPONENT_0_SHIFT) |
 					  (BRW_VFCOMPONENT_STORE_SRC <<
@@ -1872,7 +1872,7 @@ i965_composite(PixmapPtr dest, int srcX, int srcY, int maskX, int maskY,
 	OUT_RELOC(vb_bo, I915_GEM_DOMAIN_VERTEX, 0,
 		  render_state->vb_offset * 4);
 
-	if (IS_IGDNG(intel))
+	if (IS_GEN5(intel))
 		OUT_RELOC(vb_bo, I915_GEM_DOMAIN_VERTEX, 0,
 			  render_state->vb_offset * 4 + i * 4);
 	else
@@ -1930,7 +1930,7 @@ void gen4_render_state_init(ScrnInfoPtr scrn)
 	render_state->vs_state_bo = gen4_create_vs_unit_state(scrn);
 
 	/* Set up the two SF states (one for blending with a mask, one without) */
-	if (IS_IGDNG(intel)) {
+	if (IS_GEN5(intel)) {
 		sf_kernel_bo = intel_bo_alloc_for_data(scrn,
 						       sf_kernel_static_gen5,
 						       sizeof
@@ -1958,7 +1958,7 @@ void gen4_render_state_init(ScrnInfoPtr scrn)
 	drm_intel_bo_unreference(sf_kernel_mask_bo);
 
 	for (m = 0; m < WM_KERNEL_COUNT; m++) {
-		if (IS_IGDNG(intel))
+		if (IS_GEN5(intel))
 			render_state->wm_kernel_bo[m] =
 			    intel_bo_alloc_for_data(scrn,
 						    wm_kernels_gen5[m].data,
@@ -1989,7 +1989,7 @@ void gen4_render_state_init(ScrnInfoPtr scrn)
 								      border_color_bo);
 
 					for (m = 0; m < WM_KERNEL_COUNT; m++) {
-						if (IS_IGDNG(intel))
+						if (IS_GEN5(intel))
 							render_state->
 							    wm_state_bo[m][i][j]
 							    [k][l] =
diff --git a/src/i965_video.c b/src/i965_video.c
index c0cbd4b..4ededde 100644
--- a/src/i965_video.c
+++ b/src/i965_video.c
@@ -512,7 +512,7 @@ static drm_intel_bo *i965_create_vs_state(ScrnInfoPtr scrn)
 		return NULL;
 
 	/* Set up the vertex shader to be disabled (passthrough) */
-	if (IS_IGDNG(intel))
+	if (IS_GEN5(intel))
 		vs_state->thread4.nr_urb_entries = URB_VS_ENTRIES >> 2;
 	else
 		vs_state->thread4.nr_urb_entries = URB_VS_ENTRIES;
@@ -547,7 +547,7 @@ static drm_intel_bo *i965_create_sf_state(ScrnInfoPtr scrn)
 	drm_intel_bo *sf_bo, *kernel_bo;
 	struct brw_sf_unit_state *sf_state;
 
-	if (IS_IGDNG(intel))
+	if (IS_GEN5(intel))
 		kernel_bo =
 		    i965_create_program(scrn, &sf_kernel_static_gen5[0][0],
 					sizeof(sf_kernel_static_gen5));
@@ -612,7 +612,7 @@ static drm_intel_bo *i965_create_wm_state(ScrnInfoPtr scrn,
 	struct brw_wm_unit_state *wm_state;
 
 	if (is_packed) {
-		if (IS_IGDNG(intel))
+		if (IS_GEN5(intel))
 			kernel_bo =
 			    i965_create_program(scrn,
 						&ps_kernel_packed_static_gen5[0]
@@ -626,7 +626,7 @@ static drm_intel_bo *i965_create_wm_state(ScrnInfoPtr scrn,
 						sizeof
 						(ps_kernel_packed_static));
 	} else {
-		if (IS_IGDNG(intel))
+		if (IS_GEN5(intel))
 			kernel_bo =
 			    i965_create_program(scrn,
 						&ps_kernel_planar_static_gen5[0]
@@ -664,7 +664,7 @@ static drm_intel_bo *i965_create_wm_state(ScrnInfoPtr scrn,
 	/* binding table entry count is only used for prefetching, and it has to
 	 * be set 0 for IGDNG
 	 */
-	if (IS_IGDNG(intel))
+	if (IS_GEN5(intel))
 		wm_state->thread1.binding_table_entry_count = 0;
 
 	/* Though we never use the scratch space in our WM kernel, it has to be
@@ -682,7 +682,7 @@ static drm_intel_bo *i965_create_wm_state(ScrnInfoPtr scrn,
 	    intel_emit_reloc(wm_bo, offsetof(struct brw_wm_unit_state, wm4),
 			     sampler_bo, 0,
 			     I915_GEM_DOMAIN_INSTRUCTION, 0) >> 5;
-	if (IS_IGDNG(intel))
+	if (IS_GEN5(intel))
 		wm_state->wm4.sampler_count = 0;
 	else
 		wm_state->wm4.sampler_count = 1;	/* 1-4 samplers used */
@@ -788,7 +788,7 @@ i965_emit_video_setup(ScrnInfoPtr scrn, drm_intel_bo * bind_bo, int n_src_surf)
 
 	/* brw_debug (scrn, "before base address modify"); */
 	/* Match Mesa driver setup */
-	if (IS_G4X(intel) || IS_IGDNG(intel))
+	if (INTEL_INFO(intel)->gen >= 45)
 		OUT_BATCH(NEW_PIPELINE_SELECT | PIPELINE_SELECT_3D);
 	else
 		OUT_BATCH(BRW_PIPELINE_SELECT | PIPELINE_SELECT_3D);
@@ -801,7 +801,7 @@ i965_emit_video_setup(ScrnInfoPtr scrn, drm_intel_bo * bind_bo, int n_src_surf)
 	/* Zero out the two base address registers so all offsets are
 	 * absolute
 	 */
-	if (IS_IGDNG(intel)) {
+	if (IS_GEN5(intel)) {
 		OUT_BATCH(BRW_STATE_BASE_ADDRESS | 6);
 		OUT_BATCH(0 | BASE_ADDRESS_MODIFY);	/* Generate state base address */
 		OUT_BATCH(0 | BASE_ADDRESS_MODIFY);	/* Surface state base address */
@@ -832,7 +832,7 @@ i965_emit_video_setup(ScrnInfoPtr scrn, drm_intel_bo * bind_bo, int n_src_surf)
 
 	/* brw_debug (scrn, "after base address modify"); */
 
-	if (IS_IGDNG(intel))
+	if (IS_GEN5(intel))
 		pipe_ctl = BRW_PIPE_CONTROL_NOWRITE;
 	else
 		pipe_ctl = BRW_PIPE_CONTROL_NOWRITE | BRW_PIPE_CONTROL_IS_FLUSH;
@@ -905,7 +905,7 @@ i965_emit_video_setup(ScrnInfoPtr scrn, drm_intel_bo * bind_bo, int n_src_surf)
 
 	/* Set up our vertex elements, sourced from the single vertex buffer. */
 
-	if (IS_IGDNG(intel)) {
+	if (IS_GEN5(intel)) {
 		OUT_BATCH(BRW_3DSTATE_VERTEX_ELEMENTS | 3);
 		/* offset 0: X,Y -> {X, Y, 1.0, 1.0} */
 		OUT_BATCH((0 << VE0_VERTEX_BUFFER_INDEX_SHIFT) |
@@ -1190,7 +1190,7 @@ I965DisplayVideoTextured(ScrnInfoPtr scrn,
 
 		drm_intel_bo_unmap(vb_bo);
 
-		if (!IS_IGDNG(intel))
+		if (IS_GEN4(intel))
 			i965_pre_draw_debug(scrn);
 
 		/* If this command won't fit in the current batch, flush.
@@ -1212,7 +1212,7 @@ I965DisplayVideoTextured(ScrnInfoPtr scrn,
 		OUT_BATCH((0 << VB0_BUFFER_INDEX_SHIFT) |
 			  VB0_VERTEXDATA | ((4 * 4) << VB0_BUFFER_PITCH_SHIFT));
 		OUT_RELOC(vb_bo, I915_GEM_DOMAIN_VERTEX, 0, 0);
-		if (IS_IGDNG(intel))
+		if (IS_GEN5(intel))
 			OUT_RELOC(vb_bo, I915_GEM_DOMAIN_VERTEX, 0,
 				  i * 4);
 		else
@@ -1232,7 +1232,7 @@ I965DisplayVideoTextured(ScrnInfoPtr scrn,
 
 		drm_intel_bo_unreference(vb_bo);
 
-		if (!IS_IGDNG(intel))
+		if (IS_GEN4(intel))
 			i965_post_draw_debug(scrn);
 
 	}
diff --git a/src/intel.h b/src/intel.h
index b816aeb..6b05997 100644
--- a/src/intel.h
+++ b/src/intel.h
@@ -160,6 +160,11 @@ list_is_empty(struct list *head)
 	     pos = list_entry(pos->member.next, type, member))
 #endif
 
+/* remain compatible to xorg-server 1.6 */
+#ifndef MONITOR_EDID_COMPLETE_RAWDATA
+#define MONITOR_EDID_COMPLETE_RAWDATA EDID_COMPLETE_RAWDATA
+#endif
+
 struct intel_pixmap {
 	dri_bo *bo;
 
@@ -169,6 +174,7 @@ struct intel_pixmap {
 	uint8_t tiling;
 	int8_t busy :2;
 	int8_t batch_write :1;
+	int8_t offscreen :1;
 };
 
 #if HAS_DEVPRIVATEKEYREC
@@ -667,4 +673,8 @@ void intel_uxa_block_handler(intel_screen_private *intel);
 Bool intel_get_aperture_space(ScrnInfoPtr scrn, drm_intel_bo ** bo_table,
 			      int num_bos);
 
+/* intel_shadow.c */
+void intel_shadow_blt(intel_screen_private *intel);
+void intel_shadow_create(struct intel_screen_private *intel);
+
 #endif /* _I830_H_ */
diff --git a/src/intel_batchbuffer.c b/src/intel_batchbuffer.c
index a4802d0..e7ca69d 100644
--- a/src/intel_batchbuffer.c
+++ b/src/intel_batchbuffer.c
@@ -148,7 +148,7 @@ void intel_batch_emit_flush(ScrnInfoPtr scrn)
 
 	/* Big hammer, look to the pipelined flushes in future. */
 	flags = MI_WRITE_DIRTY_STATE | MI_INVALIDATE_MAP_CACHE;
-	if (IS_I965G(intel))
+	if (INTEL_INFO(intel)->gen >= 40)
 		flags = 0;
 
 	BEGIN_BATCH(1);
@@ -194,7 +194,7 @@ void intel_batch_submit(ScrnInfoPtr scrn, int flush)
 		ret = dri_bo_exec(intel->batch_bo, intel->batch_used*4,
 				  NULL, 0, 0xffffffff);
 	if (ret != 0) {
-		if (ret == -EIO && !IS_I965G(intel)) {
+		if (ret == -EIO) {
 			static int once;
 
 			/* The GPU has hung and unlikely to recover by this point. */
diff --git a/src/intel_display.c b/src/intel_display.c
index 74ce736..d32224e 100644
--- a/src/intel_display.c
+++ b/src/intel_display.c
@@ -1161,7 +1161,11 @@ intel_output_set_property(xf86OutputPtr output, Atom property,
 		}
 	}
 
-	return FALSE;
+	/* We didn't recognise this property, just report success in order
+	 * to allow the set to continue, otherwise we break setting of
+	 * common properties like EDID.
+	 */
+	return TRUE;
 }
 
 static Bool
diff --git a/src/intel_dri.c b/src/intel_dri.c
index 9804272..67f7be9 100644
--- a/src/intel_dri.c
+++ b/src/intel_dri.c
@@ -58,6 +58,8 @@ USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "windowstr.h"
 #include "shadow.h"
 
+#include "xaarop.h"
+
 #include "intel.h"
 #include "i830_reg.h"
 
@@ -71,8 +73,104 @@ typedef struct {
 	unsigned int attachment;
 } I830DRI2BufferPrivateRec, *I830DRI2BufferPrivatePtr;
 
-#if DRI2INFOREC_VERSION < 2
+static PixmapPtr get_front_buffer(DrawablePtr drawable)
+{
+	ScreenPtr screen = drawable->pScreen;
+	ScrnInfoPtr scrn = xf86Screens[screen->myNum];
+	intel_screen_private *intel = intel_get_screen_private(scrn);
+	PixmapPtr pixmap;
+
+	pixmap = get_drawable_pixmap(drawable);
+	if (!intel->use_shadow) {
+		pixmap->refcnt++;
+	} else if (pixmap_is_scanout(pixmap)) {
+		pixmap = fbCreatePixmap(screen, 0, 0, drawable->depth, 0);
+		if (pixmap) {
+			screen->ModifyPixmapHeader(pixmap,
+						   drawable->width,
+						   drawable->height,
+						   0, 0,
+						   intel->front_pitch,
+						   intel->front_buffer->virtual);
+
+			intel_set_pixmap_bo(pixmap, intel->front_buffer);
+			intel_get_pixmap_private(pixmap)->offscreen = 0;
+			if (WindowDrawable(drawable->type))
+				screen->SetWindowPixmap((WindowPtr)drawable,
+							pixmap);
+		}
+	} else if (intel_get_pixmap_bo(pixmap)) {
+		pixmap->refcnt++;
+	} else
+		pixmap = NULL;
+	return pixmap;
+}
+
+static PixmapPtr fixup_shadow(DrawablePtr drawable, PixmapPtr pixmap)
+{
+	ScreenPtr screen = drawable->pScreen;
+	PixmapPtr old = get_drawable_pixmap(drawable);
+	struct intel_pixmap *priv = intel_get_pixmap_private(pixmap);
+	GCPtr gc;
+
+	/* With an active shadow buffer, 2D pixmaps are created in
+	 * system memory and GPU acceleration of 2D render operations
+	 * is *disabled*. As DRI is still enabled, we create hardware
+	 * buffers for the clients, and need to mix this with the
+	 * 2D rendering. So we replace the system pixmap with a GTT
+	 * mapping (with the kernel enforcing coherency between
+	 * CPU and GPU) for 2D and provide the bo so that clients
+	 * can write directly to it (or read from it in the case
+	 * of TextureFromPixmap) using the GPU.
+	 *
+	 * So for a compositor with a GL backend (i.e. compiz) we have
+	 * smooth wobbly windows but incur the cost of uncached 2D rendering,
+	 * however 3D applications (games and clutter) are still fully
+	 * accelerated.
+	 */
+
+	if (drm_intel_gem_bo_map_gtt(priv->bo))
+		return pixmap;
+
+	screen->ModifyPixmapHeader(pixmap,
+				   drawable->width,
+				   drawable->height,
+				   0, 0,
+				   priv->stride,
+				   priv->bo->virtual);
+	priv->offscreen = 0;
+
+	/* Copy the current contents of the pixmap to the bo. */
+	gc = GetScratchGC(drawable->depth, screen);
+	if (gc) {
+		ValidateGC(&pixmap->drawable, gc);
+		gc->ops->CopyArea(drawable, &pixmap->drawable,
+				  gc,
+				  0, 0,
+				  drawable->width,
+				  drawable->height,
+				  0, 0);
+		FreeScratchGC(gc);
+	}
 
+	intel_set_pixmap_private(pixmap, NULL);
+	screen->DestroyPixmap(pixmap);
+
+	/* Redirect 2D rendering to the uncached GTT map of the bo */
+	screen->ModifyPixmapHeader(old,
+				   drawable->width,
+				   drawable->height,
+				   0, 0,
+				   priv->stride,
+				   priv->bo->virtual);
+
+	/* And redirect the pixmap to the new bo (for 3D). */
+	intel_set_pixmap_private(old, priv);
+	old->refcnt++;
+	return old;
+}
+
+#if DRI2INFOREC_VERSION < 2
 static DRI2BufferPtr
 I830DRI2CreateBuffers(DrawablePtr drawable, unsigned int *attachments,
 		      int count)
@@ -97,39 +195,48 @@ I830DRI2CreateBuffers(DrawablePtr drawable, unsigned int *attachments,
 
 	pDepthPixmap = NULL;
 	for (i = 0; i < count; i++) {
+		pixmap = NULL;
 		if (attachments[i] == DRI2BufferFrontLeft) {
-			pixmap = get_drawable_pixmap(drawable);
-			pixmap->refcnt++;
+			pixmap = get_front_buffer(drawable);
 		} else if (attachments[i] == DRI2BufferStencil && pDepthPixmap) {
 			pixmap = pDepthPixmap;
 			pixmap->refcnt++;
-		} else {
-			unsigned int hint = 0;
-
-			switch (attachments[i]) {
-			case DRI2BufferDepth:
-				if (SUPPORTS_YTILING(intel))
-					hint = INTEL_CREATE_PIXMAP_TILING_Y;
-				else
-					hint = INTEL_CREATE_PIXMAP_TILING_X;
-				break;
-			case DRI2BufferFakeFrontLeft:
-			case DRI2BufferFakeFrontRight:
-			case DRI2BufferBackLeft:
-			case DRI2BufferBackRight:
-				hint = INTEL_CREATE_PIXMAP_TILING_X;
-				break;
+		}
+		if (pixmap == NULL) {
+			unsigned int hint = INTEL_CREATE_PIXMAP_DRI2;
+
+			if (intel->tiling) {
+				switch (attachments[i]) {
+				case DRI2BufferDepth:
+					if (SUPPORTS_YTILING(intel))
+						hint |= INTEL_CREATE_PIXMAP_TILING_Y;
+					else
+						hint |= INTEL_CREATE_PIXMAP_TILING_X;
+					break;
+				case DRI2BufferFakeFrontLeft:
+				case DRI2BufferFakeFrontRight:
+				case DRI2BufferBackLeft:
+				case DRI2BufferBackRight:
+					hint |= INTEL_CREATE_PIXMAP_TILING_X;
+					break;
+				}
 			}
 
-			if (!intel->tiling)
-				hint = 0;
-
 			pixmap = screen->CreatePixmap(screen,
 						      drawable->width,
 						      drawable->height,
 						      drawable->depth,
 						      hint);
+			if (pixmap == NULL ||
+			    intel_get_pixmap_bo(pixmap) == NULL)
+			{
+				if (pixmap)
+					screen->DestroyPixmap(pixmap);
+				goto unwind;
+			}
 
+			if (attachment == DRI2BufferFrontLeft)
+				pixmap = fixup_shadow(drawable, pixmap);
 		}
 
 		if (attachments[i] == DRI2BufferDepth)
@@ -203,30 +310,25 @@ I830DRI2CreateBuffer(DrawablePtr drawable, unsigned int attachment,
 		return NULL;
 	}
 
-	if (attachment == DRI2BufferFrontLeft) {
-		pixmap = get_drawable_pixmap(drawable);
-		pixmap->refcnt++;
-	} else {
-		unsigned int hint = 0;
-
-		switch (attachment) {
-		case DRI2BufferDepth:
-		case DRI2BufferDepthStencil:
-			if (SUPPORTS_YTILING(intel))
-				hint = INTEL_CREATE_PIXMAP_TILING_Y;
-			else
-				hint = INTEL_CREATE_PIXMAP_TILING_X;
-			break;
-		case DRI2BufferFakeFrontLeft:
-		case DRI2BufferFakeFrontRight:
-		case DRI2BufferBackLeft:
-		case DRI2BufferBackRight:
-			hint = INTEL_CREATE_PIXMAP_TILING_X;
-			break;
-		}
+	pixmap = NULL;
+	if (attachment == DRI2BufferFrontLeft)
+		pixmap = get_front_buffer(drawable);
+	if (pixmap == NULL) {
+		unsigned int hint = INTEL_CREATE_PIXMAP_DRI2;
 
-		if (!intel->tiling)
-			hint = 0;
+		if (intel->tiling) {
+			switch (attachment) {
+			case DRI2BufferDepth:
+			case DRI2BufferDepthStencil:
+				if (SUPPORTS_YTILING(intel)) {
+					hint |= INTEL_CREATE_PIXMAP_TILING_Y;
+					break;
+				}
+			default:
+				hint |= INTEL_CREATE_PIXMAP_TILING_X;
+				break;
+			}
+		}
 
 		pixmap = screen->CreatePixmap(screen,
 					      drawable->width,
@@ -234,12 +336,16 @@ I830DRI2CreateBuffer(DrawablePtr drawable, unsigned int attachment,
 					      (format != 0) ? format :
 							      drawable->depth,
 					      hint);
-		if (pixmap == NULL) {
+		if (pixmap == NULL || intel_get_pixmap_bo(pixmap) == NULL) {
+			if (pixmap)
+				screen->DestroyPixmap(pixmap);
 			free(privates);
 			free(buffer);
 			return NULL;
 		}
 
+		if (attachment == DRI2BufferFrontLeft)
+			pixmap = fixup_shadow(drawable, pixmap);
 	}
 
 	buffer->attachment = attachment;
@@ -299,9 +405,9 @@ I830DRI2CopyRegion(DrawablePtr drawable, RegionPtr pRegion,
 	ScrnInfoPtr scrn = xf86Screens[screen->myNum];
 	intel_screen_private *intel = intel_get_screen_private(scrn);
 	DrawablePtr src = (srcPrivate->attachment == DRI2BufferFrontLeft)
-	    ? drawable : &srcPrivate->pixmap->drawable;
+		? drawable : &srcPrivate->pixmap->drawable;
 	DrawablePtr dst = (dstPrivate->attachment == DRI2BufferFrontLeft)
-	    ? drawable : &dstPrivate->pixmap->drawable;
+		? drawable : &dstPrivate->pixmap->drawable;
 	RegionPtr pCopyClip;
 	GCPtr gc;
 
@@ -350,20 +456,20 @@ I830DRI2CopyRegion(DrawablePtr drawable, RegionPtr pRegion,
 			 * of extra time for the blitter to start up and
 			 * do its job for a full height blit
 			 */
-			if (full_height && !IS_I965G(intel))
+			if (full_height && INTEL_INFO(intel)->gen < 40)
 			    y2 -= 2;
 
 			if (pipe == 0) {
 				event = MI_WAIT_FOR_PIPEA_SCAN_LINE_WINDOW;
 				load_scan_lines_pipe =
 				    MI_LOAD_SCAN_LINES_DISPLAY_PIPEA;
-				if (full_height && IS_I965G(intel))
+				if (full_height && INTEL_INFO(intel)->gen >= 40)
 				    event = MI_WAIT_FOR_PIPEA_SVBLANK;
 			} else {
 				event = MI_WAIT_FOR_PIPEB_SCAN_LINE_WINDOW;
 				load_scan_lines_pipe =
 				    MI_LOAD_SCAN_LINES_DISPLAY_PIPEB;
-				if (full_height && IS_I965G(intel))
+				if (full_height && INTEL_INFO(intel)->gen >= 40)
 				    event = MI_WAIT_FOR_PIPEB_SVBLANK;
 			}
 
@@ -399,11 +505,38 @@ I830DRI2CopyRegion(DrawablePtr drawable, RegionPtr pRegion,
 	 * that will happen before the client tries to render
 	 * again. */
 
-	(*gc->ops->CopyArea) (src, dst,
-			       gc,
-			       0, 0,
-			       drawable->width, drawable->height,
-			       0, 0);
+	/* Re-enable 2D acceleration... */
+	if (intel->use_shadow) {
+		struct intel_pixmap *src_pixmap, *dst_pixmap;
+
+		src_pixmap = intel_get_pixmap_private(get_drawable_pixmap(src));
+		if (src_pixmap) {
+			src_pixmap->offscreen = 1;
+			src_pixmap->busy = 1;
+		}
+
+		dst_pixmap = intel_get_pixmap_private(get_drawable_pixmap(dst));
+		if (dst_pixmap) {
+			dst_pixmap->offscreen = 1;
+			dst_pixmap->busy = 1;
+		}
+
+		gc->ops->CopyArea(src, dst, gc,
+				  0, 0,
+				  drawable->width, drawable->height,
+				  0, 0);
+
+		/* and restore 2D/3D coherency */
+		if (src_pixmap)
+			src_pixmap->offscreen = 0;
+		if (dst_pixmap)
+			dst_pixmap->offscreen = 0;
+	} else {
+		gc->ops->CopyArea(src, dst, gc,
+				  0, 0,
+				  drawable->width, drawable->height,
+				  0, 0);
+	}
 	FreeScratchGC(gc);
 }
 
@@ -1047,7 +1180,7 @@ Bool I830DRI2ScreenInit(ScreenPtr screen)
 	intel->deviceName = drmGetDeviceNameFromFd(intel->drmSubFD);
 	memset(&info, '\0', sizeof(info));
 	info.fd = intel->drmSubFD;
-	info.driverName = IS_I965G(intel) ? "i965" : "i915";
+	info.driverName = INTEL_INFO(intel)->gen < 40 ? "i915" : "i965";
 	info.deviceName = intel->deviceName;
 
 #if DRI2INFOREC_VERSION == 1
diff --git a/src/intel_driver.c b/src/intel_driver.c
index d086d94..b16913b 100644
--- a/src/intel_driver.c
+++ b/src/intel_driver.c
@@ -262,33 +262,6 @@ static void PreInitCleanup(ScrnInfoPtr scrn)
 	scrn->driverPrivate = NULL;
 }
 
-/*
- * DRM mode setting Linux only at this point... later on we could
- * add a wrapper here.
- */
-static Bool intel_kernel_mode_enabled(ScrnInfoPtr scrn)
-{
-	struct pci_device *dev;
-	char id[20];
-	int ret;
-
-	dev = xf86GetPciInfoForEntity(xf86GetEntityInfo(scrn->entityList[0])->index);
-	snprintf(id, sizeof(id),
-		 "pci:%04x:%02x:%02x.%d",
-		 dev->domain, dev->bus, dev->dev, dev->func);
-
-	ret = drmCheckModesettingSupported(id);
-	if (ret) {
-		if (xf86LoadKernelModule("i915"))
-			ret = drmCheckModesettingSupported(id);
-	}
-	/* Be nice to the user and load fbcon too */
-	if (!ret)
-		(void)xf86LoadKernelModule("fbcon");
-
-	return ret == 0;
-}
-
 static void intel_check_chipset_option(ScrnInfoPtr scrn)
 {
 	intel_screen_private *intel = intel_get_screen_private(scrn);
@@ -513,18 +486,10 @@ static Bool I830PreInit(ScrnInfoPtr scrn, int flags)
 	EntityInfoPtr pEnt;
 	int flags24;
 	Gamma zeros = { 0.0, 0.0, 0.0 };
-	int drm_mode_setting;
 
 	if (scrn->numEntities != 1)
 		return FALSE;
 
-	drm_mode_setting = intel_kernel_mode_enabled(scrn);
-	if (!drm_mode_setting) {
-		xf86DrvMsg(scrn->scrnIndex, X_ERROR,
-			   "No kernel modesetting driver detected.\n");
-		return FALSE;
-	}
-
 	pEnt = xf86GetEntityInfo(scrn->entityList[0]);
 
 	if (flags & PROBE_DETECT)
@@ -595,22 +560,27 @@ static Bool I830PreInit(ScrnInfoPtr scrn, int flags)
 
 	intel->force_fallback =
 		drmCommandNone(intel->drmSubFD, DRM_I915_GEM_THROTTLE) != 0;
-	intel->use_shadow = FALSE;
 
 	/* Enable tiling by default */
 	intel->tiling = TRUE;
 
 	/* Allow user override if they set a value */
-	if (xf86IsOptionSet(intel->Options, OPTION_TILING)) {
+	if (!ALWAYS_TILING(intel) && xf86IsOptionSet(intel->Options, OPTION_TILING)) {
 		if (xf86ReturnOptValBool(intel->Options, OPTION_TILING, FALSE))
 			intel->tiling = TRUE;
 		else
 			intel->tiling = FALSE;
 	}
 
+	intel->use_shadow = FALSE;
+	if (IS_GEN6(intel))
+		intel->use_shadow = TRUE;
+
 	if (xf86IsOptionSet(intel->Options, OPTION_SHADOW)) {
-		if (xf86ReturnOptValBool(intel->Options, OPTION_SHADOW, FALSE))
-			intel->force_fallback = intel->use_shadow = TRUE;
+		intel->use_shadow =
+			xf86ReturnOptValBool(intel->Options,
+					     OPTION_SHADOW,
+					     FALSE);
 	}
 
 	if (intel->use_shadow) {
@@ -698,12 +668,10 @@ void IntelEmitInvarientState(ScrnInfoPtr scrn)
 	if (intel->last_3d != LAST_3D_OTHER)
 		return;
 
-	if (!IS_I965G(intel)) {
-		if (IS_I9XX(intel))
-			I915EmitInvarientState(scrn);
-		else
-			I830EmitInvarientState(scrn);
-	}
+	if (IS_GEN2(intel))
+		I830EmitInvarientState(scrn);
+	else if IS_GEN3(intel)
+		I915EmitInvarientState(scrn);
 }
 
 static void
@@ -846,7 +814,7 @@ I830ScreenInit(int scrnIndex, ScreenPtr screen, int argc, char **argv)
 	MessageType from;
 #endif
 	struct pci_device *const device = intel->PciInfo;
-	int fb_bar = IS_I9XX(intel) ? 2 : 0;
+	int fb_bar = IS_GEN2(intel) ? 0 : 2;
 
 	/*
 	 * The "VideoRam" config file parameter specifies the maximum amount of
@@ -902,7 +870,7 @@ I830ScreenInit(int scrnIndex, ScreenPtr screen, int argc, char **argv)
 
 	intel_batch_init(scrn);
 
-	if (IS_I965G(intel))
+	if (INTEL_INFO(intel)->gen >= 40)
 		gen4_render_state_init(scrn);
 
 	miClearVisualTypes();
@@ -1002,7 +970,7 @@ I830ScreenInit(int scrnIndex, ScreenPtr screen, int argc, char **argv)
 	xf86DPMSInit(screen, xf86DPMSSet, 0);
 
 #ifdef INTEL_XVMC
-	if (IS_I965G(intel))
+	if (INTEL_INFO(intel)->gen >= 40)
 		intel->XvMCEnabled = TRUE;
 	from = ((intel->directRenderingType == DRI_DRI2) &&
 		xf86GetOptValBool(intel->Options, OPTION_XVMC,
@@ -1145,10 +1113,7 @@ static Bool I830CloseScreen(int scrnIndex, ScreenPtr screen)
 	}
 
 	if (intel->shadow_buffer) {
-		if (IS_I8XX(intel))
-			drm_intel_bo_unreference(intel->shadow_buffer);
-		else
-			free(intel->shadow_buffer);
+		free(intel->shadow_buffer);
 		intel->shadow_buffer = NULL;
 	}
 
@@ -1161,7 +1126,7 @@ static Bool I830CloseScreen(int scrnIndex, ScreenPtr screen)
 
 	intel_batch_teardown(scrn);
 
-	if (IS_I965G(intel))
+	if (INTEL_INFO(intel)->gen >= 40)
 		gen4_render_state_cleanup(scrn);
 
 	xf86_cursors_fini(screen);
diff --git a/src/intel_driver.h b/src/intel_driver.h
index b55c8c9..be8ec5f 100644
--- a/src/intel_driver.h
+++ b/src/intel_driver.h
@@ -201,74 +201,38 @@
 #define SUBSYS_ID(p)      (p)->subdevice_id
 #define CHIP_REVISION(p)  (p)->revision
 
-#define IS_I810(pI810) (DEVICE_ID(pI810->PciInfo) == PCI_CHIP_I810 ||	\
-			DEVICE_ID(pI810->PciInfo) == PCI_CHIP_I810_DC100 || \
-			DEVICE_ID(pI810->PciInfo) == PCI_CHIP_I810_E)
-#define IS_I815(pI810) (DEVICE_ID(pI810->PciInfo) == PCI_CHIP_I815)
-#define IS_I830(pI810) (DEVICE_ID(pI810->PciInfo) == PCI_CHIP_I830_M)
-#define IS_845G(pI810) (DEVICE_ID(pI810->PciInfo) == PCI_CHIP_845_G)
-#define IS_I85X(pI810)  (DEVICE_ID(pI810->PciInfo) == PCI_CHIP_I855_GM || \
-			 DEVICE_ID(pI810->PciInfo) == PCI_CHIP_I854)
-#define IS_I852(pI810)  (DEVICE_ID(pI810->PciInfo) == PCI_CHIP_I855_GM && (pI810->variant == I852_GM || pI810->variant == I852_GME))
-#define IS_I854(pI810)  (DEVICE_ID(pI810->PciInfo) == PCI_CHIP_I854)
-#define IS_I855(pI810)  (DEVICE_ID(pI810->PciInfo) == PCI_CHIP_I855_GM && (pI810->variant == I855_GM || pI810->variant == I855_GME))
-#define IS_I865G(pI810) (DEVICE_ID(pI810->PciInfo) == PCI_CHIP_I865_G)
-#define IS_I8XX(pI810)	(IS_I830(pI810) || IS_845G(pI810) || IS_I85X(pI810) || IS_I865G(pI810))
+#define INTEL_INFO(intel) ((intel)->chipset.info)
+#define IS_GENx(intel, X) (INTEL_INFO(intel)->gen >= 10*(X) && INTEL_INFO(intel)->gen < 10*((X)+1))
+#define IS_GEN1(intel) IS_GENx(intel, 1)
+#define IS_GEN2(intel) IS_GENx(intel, 2)
+#define IS_GEN3(intel) IS_GENx(intel, 3)
+#define IS_GEN4(intel) IS_GENx(intel, 4)
+#define IS_GEN5(intel) IS_GENx(intel, 5)
+#define IS_GEN6(intel) IS_GENx(intel, 6)
+
+/* Some chips have specific errata (or limits) that we need to workaround. */
+#define IS_I830(intel) (DEVICE_ID((intel)->PciInfo) == PCI_CHIP_I830_M)
+#define IS_845G(intel) (DEVICE_ID((intel)->PciInfo) == PCI_CHIP_845_G)
+#define IS_I865G(intel) (DEVICE_ID((intel)->PciInfo) == PCI_CHIP_I865_G)
 
 #define IS_I915G(pI810) (DEVICE_ID(pI810->PciInfo) == PCI_CHIP_I915_G || DEVICE_ID(pI810->PciInfo) == PCI_CHIP_E7221_G)
 #define IS_I915GM(pI810) (DEVICE_ID(pI810->PciInfo) == PCI_CHIP_I915_GM)
-#define IS_I945G(pI810) (DEVICE_ID(pI810->PciInfo) == PCI_CHIP_I945_G)
-#define IS_I945GM(pI810) (DEVICE_ID(pI810->PciInfo) == PCI_CHIP_I945_GM || DEVICE_ID(pI810->PciInfo) == PCI_CHIP_I945_GME)
-#define IS_IGDGM(pI810) (DEVICE_ID(pI810->PciInfo) == PCI_CHIP_IGD_GM)
-#define IS_IGDG(pI810) (DEVICE_ID(pI810->PciInfo) == PCI_CHIP_IGD_G)
-#define IS_IGD(pI810) (IS_IGDG(pI810) || IS_IGDGM(pI810))
-#define IS_GM45(pI810) (DEVICE_ID(pI810->PciInfo) == PCI_CHIP_GM45_GM)
-#define IS_G4X(pI810) (DEVICE_ID(pI810->PciInfo) == PCI_CHIP_IGD_E_G || DEVICE_ID(pI810->PciInfo) == PCI_CHIP_G45_G || DEVICE_ID(pI810->PciInfo) == PCI_CHIP_Q45_G || DEVICE_ID(pI810->PciInfo) == PCI_CHIP_G41_G || DEVICE_ID(pI810->PciInfo) == PCI_CHIP_B43_G || IS_GM45(pI810))
-#define IS_I965GM(pI810) (DEVICE_ID(pI810->PciInfo) == PCI_CHIP_I965_GM || DEVICE_ID(pI810->PciInfo) == PCI_CHIP_I965_GME)
+
 #define IS_965_Q(pI810) (DEVICE_ID(pI810->PciInfo) == PCI_CHIP_I965_Q)
-#define IS_IGDNG_D(pI810) (DEVICE_ID(pI810->PciInfo) == PCI_CHIP_IGDNG_D_G)
-#define IS_IGDNG_M(pI810) (DEVICE_ID(pI810->PciInfo) == PCI_CHIP_IGDNG_M_G)
-#define IS_IGDNG(pI810) (IS_IGDNG_D(pI810) || IS_IGDNG_M(pI810))
-#define IS_I965G(pI810) (DEVICE_ID(pI810->PciInfo) == PCI_CHIP_I965_G || \
-			 DEVICE_ID(pI810->PciInfo) == PCI_CHIP_G35_G || \
-			 DEVICE_ID(pI810->PciInfo) == PCI_CHIP_I965_Q || \
-			 DEVICE_ID(pI810->PciInfo) == PCI_CHIP_I946_GZ || \
-			 DEVICE_ID(pI810->PciInfo) == PCI_CHIP_I965_GM || \
-			 DEVICE_ID(pI810->PciInfo) == PCI_CHIP_I965_GME || \
-			 IS_G4X(pI810) || \
-			 IS_IGDNG(pI810) || \
-			 IS_GEN6(pI810))
-#define IS_G33CLASS(pI810) (DEVICE_ID(pI810->PciInfo) == PCI_CHIP_G33_G ||\
- 			    DEVICE_ID(pI810->PciInfo) == PCI_CHIP_Q35_G ||\
-			    DEVICE_ID(pI810->PciInfo) == PCI_CHIP_Q33_G || \
-			    IS_IGD(pI810))
-
-#define IS_I9XX(pI810) (IS_I915G(pI810) ||			\
-			IS_I915GM(pI810) ||			\
-			IS_I945G(pI810) ||			\
-			IS_I945GM(pI810) ||			\
-			IS_I965G(pI810) ||			\
-			IS_G33CLASS(pI810))
-
-#define IS_I915(pI810) (IS_I915G(pI810) || IS_I915GM(pI810) || IS_I945G(pI810) || IS_I945GM(pI810) || IS_G33CLASS(pI810))
-
-#define IS_GEN6(pI810) ((pI810)->PciInfo->device_id == PCI_CHIP_SANDYBRIDGE_GT1 || \
-			(pI810)->PciInfo->device_id == PCI_CHIP_SANDYBRIDGE_GT2 || \
-			(pI810)->PciInfo->device_id == PCI_CHIP_SANDYBRIDGE_GT2_PLUS || \
-			(pI810)->PciInfo->device_id == PCI_CHIP_SANDYBRIDGE_M_GT1 ||\
-			(pI810)->PciInfo->device_id == PCI_CHIP_SANDYBRIDGE_M_GT2 || \
-			(pI810)->PciInfo->device_id == PCI_CHIP_SANDYBRIDGE_M_GT2_PLUS ||\
-			(pI810)->PciInfo->device_id == PCI_CHIP_SANDYBRIDGE_S_GT)
-
-#define IS_MOBILE(pI810) (IS_I830(pI810) || IS_I85X(pI810) || IS_I915GM(pI810) || IS_I945GM(pI810) || IS_I965GM(pI810) || IS_GM45(pI810) || IS_IGD(pI810) || IS_IGDNG_M(pI810))
+
 /* supports Y tiled surfaces (pre-965 Mesa isn't ready yet) */
-#define SUPPORTS_YTILING(pI810) (IS_I965G(intel))
+#define SUPPORTS_YTILING(pI810) (INTEL_INFO(intel)->gen >= 40)
+
+#define ALWAYS_TILING(intel) IS_GEN6(intel)
 
 extern SymTabRec *intel_chipsets;
 
 struct intel_chipset {
     const char *name;
     int variant;
+    const struct intel_device_info {
+	    int gen;
+    } *info;
 };
 
 void intel_detect_chipset(ScrnInfoPtr scrn,
diff --git a/src/intel_hwmc.c b/src/intel_hwmc.c
index a0861ec..d626725 100644
--- a/src/intel_hwmc.c
+++ b/src/intel_hwmc.c
@@ -71,17 +71,17 @@ static int create_context(ScrnInfoPtr scrn, XvMCContextPtr pContext,
 
 	*num_priv = sizeof(struct intel_xvmc_hw_context) >> 2;
 
-	if (IS_I915(intel)) {
+	if (IS_GEN3(intel)) {
 		contextRec->type = XVMC_I915_MPEG2_MC;
 		contextRec->i915.use_phys_addr = 0;
 	} else {
-		if (IS_G4X(intel) || IS_IGDNG(intel))
+		if (INTEL_INFO(intel)->gen >= 45)
 			contextRec->type = XVMC_I965_MPEG2_VLD;
 		else
 			contextRec->type = XVMC_I965_MPEG2_MC;
-		contextRec->i965.is_g4x = IS_G4X(intel);
+		contextRec->i965.is_g4x = INTEL_INFO(intel)->gen == 45;
 		contextRec->i965.is_965_q = IS_965_Q(intel);
-		contextRec->i965.is_igdng = IS_IGDNG(intel);
+		contextRec->i965.is_igdng = IS_GEN5(intel);
 	}
 
 	return Success;
@@ -202,7 +202,7 @@ Bool intel_xvmc_adaptor_init(ScreenPtr pScreen)
 	if (IS_I915G(intel) || IS_I915GM(intel))
 		return FALSE;
 
-	if (!IS_I9XX(intel)) {
+	if (IS_GEN2(intel)) {
 		ErrorF("Your chipset doesn't support XvMC.\n");
 		return FALSE;
 	}
@@ -223,11 +223,11 @@ Bool intel_xvmc_adaptor_init(ScreenPtr pScreen)
 	pAdapt->CreateSubpicture =  create_subpicture;
 	pAdapt->DestroySubpicture = destroy_subpicture;
 
-	if (IS_I915(intel)) {
+	if (IS_GEN3(intel)) {
 		name = "i915_xvmc",
 		pAdapt->num_surfaces = ARRAY_SIZE(surface_info_i915);
 		pAdapt->surfaces = surface_info_i915;
-	} else if (IS_G4X(intel) || IS_IGDNG(intel)) {
+	} else if (INTEL_INFO(intel)->gen >= 45) {
 		name = "xvmc_vld",
 		pAdapt->num_surfaces = ARRAY_SIZE(surface_info_vld);
 		pAdapt->surfaces = surface_info_vld;
diff --git a/src/intel_memory.c b/src/intel_memory.c
index 3a25ba6..f68db34 100644
--- a/src/intel_memory.c
+++ b/src/intel_memory.c
@@ -94,14 +94,14 @@ unsigned long intel_get_fence_size(intel_screen_private *intel, unsigned long si
 	unsigned long i;
 	unsigned long start;
 
-	if (IS_I965G(intel)) {
+	if (INTEL_INFO(intel)->gen >= 40) {
 		/* The 965 can have fences at any page boundary. */
 		return ALIGN(size, GTT_PAGE_SIZE);
 	} else {
 		/* Align the size to a power of two greater than the smallest fence
 		 * size.
 		 */
-		if (IS_I9XX(intel))
+		if (IS_GEN3(intel))
 			start = MB(1);
 		else
 			start = KB(512);
@@ -126,8 +126,8 @@ intel_get_fence_pitch(intel_screen_private *intel, unsigned long pitch,
 	if (tiling_mode == I915_TILING_NONE)
 		return pitch;
 
-	/* 965 is flexible */
-	if (IS_I965G(intel))
+	/* 965+ is flexible */
+	if (INTEL_INFO(intel)->gen >= 40)
 		return ALIGN(pitch, tile_width);
 
 	/* Pre-965 needs power of two tile width */
@@ -144,17 +144,16 @@ intel_check_display_stride(ScrnInfoPtr scrn, int stride, Bool tiling)
 
 	/* 8xx spec has always 8K limit, but tests show larger limit in
 	   non-tiling mode, which makes large monitor work. */
-	if (IS_I8XX(intel) && tiling)
-		limit = KB(8);
-
-	if (IS_I915(intel) && tiling)
-		limit = KB(8);
-
-	if (IS_I965G(intel) && tiling)
-		limit = KB(16);
-
-	if (IS_IGDNG(intel) && tiling)
-		limit = KB(32);
+	if (tiling) {
+		if (IS_GEN2(intel))
+			limit = KB(8);
+		else if (IS_GEN3(intel))
+			limit = KB(8);
+		else if (IS_GEN4(intel))
+			limit = KB(16);
+		else
+			limit = KB(32);
+	}
 
 	if (stride <= limit)
 		return TRUE;
diff --git a/src/intel_module.c b/src/intel_module.c
index 53e1cb6..898e697 100644
--- a/src/intel_module.c
+++ b/src/intel_module.c
@@ -37,6 +37,40 @@
 #include "intel_driver.h"
 #include "legacy/legacy.h"
 
+#include <xf86drmMode.h>
+
+static const struct intel_device_info intel_i81x_info = {
+	.gen = 10,
+};
+
+static const struct intel_device_info intel_i8xx_info = {
+	.gen = 20,
+};
+
+static const struct intel_device_info intel_i915_info = {
+	.gen = 30,
+};
+
+static const struct intel_device_info intel_g33_info = {
+	.gen = 33,
+};
+
+static const struct intel_device_info intel_i965_info = {
+	.gen = 40,
+};
+
+static const struct intel_device_info intel_g4x_info = {
+	.gen = 45,
+};
+
+static const struct intel_device_info intel_ironlake_info = {
+	.gen = 50,
+};
+
+static const struct intel_device_info intel_sandybridge_info = {
+	.gen = 60,
+};
+
 static const SymTabRec _intel_chipsets[] = {
     {PCI_CHIP_I810,		"i810"},
     {PCI_CHIP_I810_DC100,	"i810-dc100"},
@@ -186,24 +220,31 @@ void intel_detect_chipset(ScrnInfoPtr scrn,
     switch (DEVICE_ID(pci)) {
     case PCI_CHIP_I810:
 	chipset->name = "i810";
+	chipset->info = &intel_i81x_info;
 	break;
     case PCI_CHIP_I810_DC100:
 	chipset->name = "i810-dc100";
+	chipset->info = &intel_i81x_info;
 	break;
     case PCI_CHIP_I810_E:
 	chipset->name = "i810e";
+	chipset->info = &intel_i81x_info;
 	break;
     case PCI_CHIP_I815:
 	chipset->name = "i815";
+	chipset->info = &intel_i81x_info;
 	break;
     case PCI_CHIP_I830_M:
 	chipset->name = "830M";
+	chipset->info = &intel_i8xx_info;
 	break;
     case PCI_CHIP_845_G:
 	chipset->name = "845G";
+	chipset->info = &intel_i8xx_info;
 	break;
     case PCI_CHIP_I854:
 	chipset->name = "854";
+	chipset->info = &intel_i8xx_info;
 	break;
     case PCI_CHIP_I855_GM:
 	/* Check capid register to find the chipset variant */
@@ -230,84 +271,111 @@ void intel_detect_chipset(ScrnInfoPtr scrn,
 	    chipset->name = "852GM/855GM (unknown variant)";
 	    break;
 	}
+	chipset->info = &intel_i8xx_info;
 	break;
     case PCI_CHIP_I865_G:
 	chipset->name = "865G";
+	chipset->info = &intel_i8xx_info;
 	break;
     case PCI_CHIP_I915_G:
 	chipset->name = "915G";
+	chipset->info = &intel_i915_info;
 	break;
     case PCI_CHIP_E7221_G:
 	chipset->name = "E7221 (i915)";
+	chipset->info = &intel_i915_info;
 	break;
     case PCI_CHIP_I915_GM:
 	chipset->name = "915GM";
+	chipset->info = &intel_i915_info;
 	break;
     case PCI_CHIP_I945_G:
 	chipset->name = "945G";
+	chipset->info = &intel_i915_info;
 	break;
     case PCI_CHIP_I945_GM:
 	chipset->name = "945GM";
+	chipset->info = &intel_i915_info;
 	break;
     case PCI_CHIP_I945_GME:
 	chipset->name = "945GME";
+	chipset->info = &intel_i915_info;
 	break;
     case PCI_CHIP_IGD_GM:
 	chipset->name = "Pineview GM";
+	chipset->info = &intel_g33_info;
 	break;
     case PCI_CHIP_IGD_G:
 	chipset->name = "Pineview G";
+	chipset->info = &intel_g33_info;
 	break;
     case PCI_CHIP_I965_G:
 	chipset->name = "965G";
+	chipset->info = &intel_i965_info;
 	break;
     case PCI_CHIP_G35_G:
 	chipset->name = "G35";
+	chipset->info = &intel_g33_info;
 	break;
     case PCI_CHIP_I965_Q:
 	chipset->name = "965Q";
+	chipset->info = &intel_i965_info;
 	break;
     case PCI_CHIP_I946_GZ:
 	chipset->name = "946GZ";
+	chipset->info = &intel_i915_info;
 	break;
     case PCI_CHIP_I965_GM:
 	chipset->name = "965GM";
+	chipset->info = &intel_i965_info;
 	break;
     case PCI_CHIP_I965_GME:
 	chipset->name = "965GME/GLE";
+	chipset->info = &intel_i965_info;
 	break;
     case PCI_CHIP_G33_G:
 	chipset->name = "G33";
+	chipset->info = &intel_g33_info;
 	break;
     case PCI_CHIP_Q35_G:
 	chipset->name = "Q35";
+	chipset->info = &intel_g33_info;
 	break;
     case PCI_CHIP_Q33_G:
 	chipset->name = "Q33";
+	chipset->info = &intel_g33_info;
 	break;
     case PCI_CHIP_GM45_GM:
 	chipset->name = "GM45";
+	chipset->info = &intel_g4x_info;
 	break;
     case PCI_CHIP_IGD_E_G:
 	chipset->name = "4 Series";
+	chipset->info = &intel_g4x_info;
 	break;
     case PCI_CHIP_G45_G:
 	chipset->name = "G45/G43";
+	chipset->info = &intel_g4x_info;
 	break;
     case PCI_CHIP_Q45_G:
 	chipset->name = "Q45/Q43";
+	chipset->info = &intel_g4x_info;
 	break;
     case PCI_CHIP_G41_G:
 	chipset->name = "G41";
+	chipset->info = &intel_g4x_info;
 	break;
     case PCI_CHIP_B43_G:
 	chipset->name = "B43";
+	chipset->info = &intel_g4x_info;
 	break;
     case PCI_CHIP_IGDNG_D_G:
 	chipset->name = "Clarkdale";
+	chipset->info = &intel_ironlake_info;
 	break;
     case PCI_CHIP_IGDNG_M_G:
 	chipset->name = "Arrandale";
+	chipset->info = &intel_ironlake_info;
 	break;
     case PCI_CHIP_SANDYBRIDGE_GT1:
     case PCI_CHIP_SANDYBRIDGE_GT2:
@@ -317,6 +385,7 @@ void intel_detect_chipset(ScrnInfoPtr scrn,
     case PCI_CHIP_SANDYBRIDGE_M_GT2_PLUS:
     case PCI_CHIP_SANDYBRIDGE_S_GT:
 	chipset->name = "Sandybridge";
+	chipset->info = &intel_sandybridge_info;
 	break;
     default:
 	chipset->name = "unknown chipset";
@@ -361,6 +430,27 @@ static Bool intel_driver_func(ScrnInfoPtr pScrn,
     }
 }
 
+static Bool has_kernel_mode_setting(struct pci_device *dev)
+{
+	char id[20];
+	int ret;
+
+	snprintf(id, sizeof(id),
+		 "pci:%04x:%02x:%02x.%d",
+		 dev->domain, dev->bus, dev->dev, dev->func);
+
+	ret = drmCheckModesettingSupported(id);
+	if (ret) {
+		if (xf86LoadKernelModule("i915"))
+			ret = drmCheckModesettingSupported(id);
+	}
+	/* Be nice to the user and load fbcon too */
+	if (!ret)
+		(void)xf86LoadKernelModule("fbcon");
+
+	return ret == 0;
+}
+
 /*
  * intel_pci_probe --
  *
@@ -373,11 +463,26 @@ static Bool intel_pci_probe (DriverPtr		driver,
 			     struct pci_device	*device,
 			     intptr_t		match_data)
 {
-    ScrnInfoPtr scrn = NULL;
+    ScrnInfoPtr scrn;
+
+    if (!has_kernel_mode_setting(device)) {
+#if KMS_ONLY
+	    return FALSE;
+#else
+	    switch (DEVICE_ID(device)) {
+	    case PCI_CHIP_I810:
+	    case PCI_CHIP_I810_DC100:
+	    case PCI_CHIP_I810_E:
+	    case PCI_CHIP_I815:
+		    break;
+	    default:
+		    return FALSE;
+	    }
+#endif
+    }
 
-    scrn = xf86ConfigPciEntity(scrn, 0, entity_num, intel_pci_chipsets,
-			       NULL,
-			       NULL, NULL, NULL, NULL);
+    scrn = xf86ConfigPciEntity(NULL, 0, entity_num, intel_pci_chipsets,
+			       NULL, NULL, NULL, NULL, NULL);
     if (scrn != NULL) {
 	scrn->driverVersion = INTEL_VERSION;
 	scrn->driverName = INTEL_DRIVER_NAME;
diff --git a/src/intel_shadow.c b/src/intel_shadow.c
new file mode 100644
index 0000000..c12febc
--- /dev/null
+++ b/src/intel_shadow.c
@@ -0,0 +1,204 @@
+/**************************************************************************
+
+Copyright 2010 Intel Corporation
+All Rights Reserved.
+
+Permission is hereby granted, free of charge, to any person obtaining a
+copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sub license, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice (including the
+next paragraph) shall be included in all copies or substantial portions
+of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+IN NO EVENT SHALL PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR
+ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+*/
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "xf86.h"
+#include "xaarop.h"
+#include "intel.h"
+#include "i830_reg.h"
+
+static dri_bo *
+intel_shadow_create_bo(intel_screen_private *intel,
+		       int16_t x1, int16_t y1,
+		       int16_t x2, int16_t y2,
+		       int *pitch)
+{
+	int w = x2 - x1, h = y2 - y1;
+	int size = h * w * intel->cpp;
+	dri_bo *bo;
+
+	bo = drm_intel_bo_alloc(intel->bufmgr, "shadow", size, 0);
+	if (bo && drm_intel_gem_bo_map_gtt(bo) == 0) {
+		char *dst = bo->virtual;
+		char *src = intel->shadow_buffer;
+		int src_pitch = intel->shadow_stride;
+		int row_length = w * intel->cpp;
+		int num_rows = h;
+		src += y1 * src_pitch + x1 * intel->cpp;
+		do {
+			memcpy (dst, src, row_length);
+			src += src_pitch;
+			dst += row_length;
+		} while (--num_rows);
+		drm_intel_gem_bo_unmap_gtt(bo);
+	}
+
+	*pitch = w * intel->cpp;
+	return bo;
+}
+
+static void intel_shadow_memcpy(intel_screen_private *intel)
+{
+	char *src_data, *dst_data;
+	unsigned int src_pitch, dst_pitch;
+	RegionPtr region;
+	BoxPtr box;
+	int n;
+
+	if (drm_intel_gem_bo_map_gtt(intel->front_buffer))
+		return;
+
+	src_data = intel->shadow_buffer;
+	dst_data = intel->front_buffer->virtual;
+
+	src_pitch = intel->shadow_stride;
+	dst_pitch = intel->front_pitch;
+
+	region = DamageRegion(intel->shadow_damage);
+	box = REGION_RECTS(region);
+	n = REGION_NUM_RECTS(region);
+	while (n--) {
+		char *src = src_data + box->y1*src_pitch + box->x1*intel->cpp;
+		char *dst = dst_data + box->y1*dst_pitch + box->x1*intel->cpp;
+		int len = (box->x2 - box->x1)*intel->cpp;
+		int row = box->y2 - box->y1;
+		while (row--) {
+			memcpy(dst, src, len);
+			src += src_pitch;
+			dst += dst_pitch;
+		}
+		box++;
+	}
+}
+
+void intel_shadow_blt(intel_screen_private *intel)
+{
+	ScrnInfoPtr scrn = intel->scrn;
+	unsigned int dst_pitch;
+	uint32_t blt, br13;
+	RegionPtr region;
+	BoxPtr box;
+	int n;
+
+	/* Can we trust the BLT? Otherwise do an uncached mmecy. */
+	if (IS_GEN2(intel) || IS_GEN6(intel)) {
+		intel_shadow_memcpy(intel);
+		return;
+	}
+
+	dst_pitch = intel->front_pitch;
+
+	blt = XY_SRC_COPY_BLT_CMD;
+	if (intel->cpp == 4)
+		blt |= (XY_SRC_COPY_BLT_WRITE_ALPHA |
+				XY_SRC_COPY_BLT_WRITE_RGB);
+
+	if (INTEL_INFO(intel)->gen >= 40) {
+		if (intel->front_tiling) {
+			dst_pitch >>= 2;
+			blt |= XY_SRC_COPY_BLT_DST_TILED;
+		}
+	}
+
+	br13 = ROP_S << 16 | dst_pitch;
+	switch (intel->cpp) {
+		default:
+		case 4: br13 |= 1 << 25; /* RGB8888 */
+		case 2: br13 |= 1 << 24; /* RGB565 */
+		case 1: break;
+	}
+
+	region = DamageRegion(intel->shadow_damage);
+	box = REGION_RECTS(region);
+	n = REGION_NUM_RECTS(region);
+	while (n--) {
+		int pitch;
+		dri_bo *bo;
+
+		bo = intel_shadow_create_bo(intel,
+					    box->x1, box->y1,
+					    box->x2, box->y2,
+					    &pitch);
+		if (bo == NULL)
+			return;
+
+		BEGIN_BATCH(8);
+		OUT_BATCH(blt);
+		OUT_BATCH(br13);
+		OUT_BATCH(box->y1 << 16 | box->x1);
+		OUT_BATCH(box->y2 << 16 | box->x2);
+		OUT_RELOC_FENCED(intel->front_buffer,
+				I915_GEM_DOMAIN_RENDER,
+				I915_GEM_DOMAIN_RENDER,
+				0);
+		OUT_BATCH(0);
+		OUT_BATCH(pitch);
+		OUT_RELOC(bo, I915_GEM_DOMAIN_RENDER, 0, 0);
+
+		ADVANCE_BATCH();
+
+		drm_intel_bo_unreference(bo);
+		box++;
+	}
+}
+
+void intel_shadow_create(struct intel_screen_private *intel)
+{
+	ScrnInfoPtr scrn = intel->scrn;
+	ScreenPtr screen = scrn->pScreen;
+	PixmapPtr pixmap;
+	int stride;
+	void *buffer;
+
+	pixmap = screen->GetScreenPixmap(screen);
+	stride = intel->cpp*scrn->virtualX;
+	buffer = malloc(stride * scrn->virtualY);
+	if (buffer &&
+	    screen->ModifyPixmapHeader(pixmap,
+				       scrn->virtualX, scrn->virtualY,
+				       -1, -1,
+				       stride, buffer)) {
+		free(intel->shadow_buffer);
+		intel->shadow_buffer = buffer;
+	} else
+		stride = intel->shadow_stride;
+
+	if (!intel->shadow_damage) {
+		intel->shadow_damage =
+			DamageCreate(NULL, NULL,
+				     DamageReportNone, TRUE,
+				     screen, intel);
+		DamageRegister(&pixmap->drawable, intel->shadow_damage);
+		DamageSetReportAfterOp(intel->shadow_damage, TRUE);
+	}
+
+	scrn->displayWidth = stride / intel->cpp;
+	intel->shadow_stride = stride;
+}
diff --git a/src/intel_uxa.c b/src/intel_uxa.c
index ef4c553..23679bc 100644
--- a/src/intel_uxa.c
+++ b/src/intel_uxa.c
@@ -96,7 +96,7 @@ ironlake_blt_workaround(ScrnInfoPtr scrn)
 	 * non-pipelined 3D instruction after each blit.
 	 */
 
-	if (IS_IGDNG(intel)) {
+	if (IS_GEN5(intel)) {
 		BEGIN_BATCH(2);
 		OUT_BATCH(CMD_POLY_STIPPLE_OFFSET << 16);
 		OUT_BATCH(0);
@@ -144,7 +144,7 @@ intel_uxa_pixmap_compute_size(PixmapPtr pixmap,
 		pitch = (w * pixmap->drawable.bitsPerPixel + 7) / 8;
 		pitch = ALIGN(pitch, 64);
 		size = pitch * ALIGN (h, 2);
-		if (!IS_I965G(intel)) {
+		if (INTEL_INFO(intel)->gen < 40) {
 			/* Older hardware requires fences to be pot size
 			 * aligned with a minimum of 1 MiB, so causes
 			 * massive overallocation for small textures.
@@ -302,7 +302,7 @@ static void i830_uxa_solid(PixmapPtr pixmap, int x1, int y1, int x2, int y2)
 			cmd |=
 			    XY_COLOR_BLT_WRITE_ALPHA | XY_COLOR_BLT_WRITE_RGB;
 
-		if (IS_I965G(intel) && intel_pixmap_tiled(pixmap)) {
+		if (INTEL_INFO(intel)->gen >= 40 && intel_pixmap_tiled(pixmap)) {
 			assert((pitch % 512) == 0);
 			pitch >>= 2;
 			cmd |= XY_COLOR_BLT_TILED;
@@ -457,7 +457,7 @@ i830_uxa_copy(PixmapPtr dest, int src_x1, int src_y1, int dst_x1,
 			    XY_SRC_COPY_BLT_WRITE_ALPHA |
 			    XY_SRC_COPY_BLT_WRITE_RGB;
 
-		if (IS_I965G(intel)) {
+		if (INTEL_INFO(intel)->gen >= 40) {
 			if (intel_pixmap_tiled(dest)) {
 				assert((dst_pitch % 512) == 0);
 				dst_pitch >>= 2;
@@ -666,6 +666,7 @@ void intel_set_pixmap_bo(PixmapPtr pixmap, dri_bo * bo)
 
 		priv->tiling = tiling;
 		priv->busy = -1;
+		priv->offscreen = 1;
 	} else {
 		if (priv != NULL) {
 			free(priv);
@@ -677,6 +678,12 @@ void intel_set_pixmap_bo(PixmapPtr pixmap, dri_bo * bo)
 	intel_set_pixmap_private(pixmap, priv);
 }
 
+static Bool intel_uxa_pixmap_is_offscreen(PixmapPtr pixmap)
+{
+	struct intel_pixmap *priv = intel_get_pixmap_private(pixmap);
+	return priv && priv->offscreen;
+}
+
 static Bool intel_uxa_prepare_access(PixmapPtr pixmap, uxa_access_t access)
 {
 	ScrnInfoPtr scrn = xf86Screens[pixmap->drawable.pScreen->myNum];
@@ -707,22 +714,6 @@ static Bool intel_uxa_prepare_access(PixmapPtr pixmap, uxa_access_t access)
 	return TRUE;
 }
 
-static void intel_uxa_finish_access(PixmapPtr pixmap)
-{
-	ScreenPtr screen = pixmap->drawable.pScreen;
-	ScrnInfoPtr scrn = xf86Screens[screen->myNum];
-	intel_screen_private *intel = intel_get_screen_private(scrn);
-	struct intel_pixmap *priv = intel_get_pixmap_private(pixmap);
-	dri_bo *bo = priv->bo;
-
-	if (priv->tiling || bo->size <= intel->max_gtt_map_size)
-		drm_intel_gem_bo_unmap_gtt(bo);
-	else
-		dri_bo_unmap(bo);
-
-	pixmap->devPrivate.ptr = NULL;
-}
-
 static Bool intel_uxa_pixmap_put_image(PixmapPtr pixmap,
 				       char *src, int src_pitch,
 				       int x, int y, int w, int h)
@@ -731,6 +722,9 @@ static Bool intel_uxa_pixmap_put_image(PixmapPtr pixmap,
 	int stride = intel_pixmap_pitch(pixmap);
 	int ret = FALSE;
 
+	if (priv == NULL || priv->bo == NULL)
+		return FALSE;
+
 	if (src_pitch == stride && w == pixmap->drawable.width && priv->tiling == I915_TILING_NONE) {
 		ret = drm_intel_bo_subdata(priv->bo, y * stride, stride * h, src) == 0;
 	} else if (drm_intel_gem_bo_map_gtt(priv->bo) == 0) {
@@ -810,6 +804,11 @@ static Bool intel_uxa_put_image(PixmapPtr pixmap,
 			if (!scratch)
 				return FALSE;
 
+			if (!intel_uxa_pixmap_is_offscreen(scratch)) {
+				screen->DestroyPixmap(scratch);
+				return FALSE;
+			}
+
 			ret = intel_uxa_pixmap_put_image(scratch, src, src_pitch, 0, 0, w, h);
 			if (ret) {
 				GCPtr gc = GetScratchGC(pixmap->drawable.depth, screen);
@@ -890,6 +889,11 @@ static Bool intel_uxa_get_image(PixmapPtr pixmap,
 		if (!scratch)
 			return FALSE;
 
+		if (!intel_uxa_pixmap_is_offscreen(scratch)) {
+			screen->DestroyPixmap(scratch);
+			return FALSE;
+		}
+
 		gc = GetScratchGC(pixmap->drawable.depth, screen);
 		if (!gc) {
 			screen->DestroyPixmap(scratch);
@@ -918,182 +922,6 @@ static Bool intel_uxa_get_image(PixmapPtr pixmap,
 	return ret;
 }
 
-static dri_bo *
-intel_shadow_create_bo(intel_screen_private *intel,
-		       int16_t x1, int16_t y1,
-		       int16_t x2, int16_t y2,
-		       int *pitch)
-{
-	int w = x2 - x1, h = y2 - y1;
-	int size = h * w * intel->cpp;
-	dri_bo *bo;
-
-	bo = drm_intel_bo_alloc(intel->bufmgr, "shadow", size, 0);
-	if (bo && drm_intel_gem_bo_map_gtt(bo) == 0) {
-		char *dst = bo->virtual;
-		char *src = intel->shadow_buffer;
-		int src_pitch = intel->shadow_stride;
-		int row_length = w * intel->cpp;
-		int num_rows = h;
-		src += y1 * src_pitch + x1 * intel->cpp;
-		do {
-			memcpy (dst, src, row_length);
-			src += src_pitch;
-			dst += row_length;
-		} while (--num_rows);
-		drm_intel_gem_bo_unmap_gtt(bo);
-	}
-
-	*pitch = w * intel->cpp;
-	return bo;
-}
-
-static void
-intel_shadow_blt(intel_screen_private *intel)
-{
-	ScrnInfoPtr scrn = intel->scrn;
-	unsigned int dst_pitch;
-	uint32_t blt, br13;
-	RegionPtr region;
-	BoxPtr box;
-	int n;
-
-	dst_pitch = intel->front_pitch;
-
-	blt = XY_SRC_COPY_BLT_CMD;
-	if (intel->cpp == 4)
-		blt |= (XY_SRC_COPY_BLT_WRITE_ALPHA |
-				XY_SRC_COPY_BLT_WRITE_RGB);
-
-	if (IS_I965G(intel)) {
-		if (intel->front_tiling) {
-			dst_pitch >>= 2;
-			blt |= XY_SRC_COPY_BLT_DST_TILED;
-		}
-	}
-
-	br13 = ROP_S << 16 | dst_pitch;
-	switch (intel->cpp) {
-		default:
-		case 4: br13 |= 1 << 25; /* RGB8888 */
-		case 2: br13 |= 1 << 24; /* RGB565 */
-		case 1: break;
-	}
-
-	region = DamageRegion(intel->shadow_damage);
-	box = REGION_RECTS(region);
-	n = REGION_NUM_RECTS(region);
-	while (n--) {
-		int pitch;
-		dri_bo *bo;
-		int offset;
-
-		if (IS_I8XX(intel)) {
-			bo = intel->shadow_buffer;
-			offset = box->x1 | box->y1 << 16;
-			pitch = intel->shadow_stride;
-		} else {
-			bo = intel_shadow_create_bo(intel,
-						    box->x1, box->y1,
-						    box->x2, box->y2,
-						    &pitch);
-			if (bo == NULL)
-				return;
-
-			offset = 0;
-		}
-
-		BEGIN_BATCH(8);
-		OUT_BATCH(blt);
-		OUT_BATCH(br13);
-		OUT_BATCH(box->y1 << 16 | box->x1);
-		OUT_BATCH(box->y2 << 16 | box->x2);
-		OUT_RELOC_FENCED(intel->front_buffer,
-				I915_GEM_DOMAIN_RENDER,
-				I915_GEM_DOMAIN_RENDER,
-				0);
-		OUT_BATCH(offset);
-		OUT_BATCH(pitch);
-		OUT_RELOC(bo, I915_GEM_DOMAIN_RENDER, 0, 0);
-
-		ADVANCE_BATCH();
-
-		if (bo != intel->shadow_buffer)
-			drm_intel_bo_unreference(bo);
-		box++;
-	}
-}
-
-static void intel_shadow_create(struct intel_screen_private *intel)
-{
-	ScrnInfoPtr scrn = intel->scrn;
-	ScreenPtr screen = scrn->pScreen;
-	PixmapPtr pixmap;
-	int stride;
-
-	pixmap = screen->GetScreenPixmap(screen);
-	if (IS_I8XX(intel)) {
-		dri_bo *bo;
-		int size;
-
-		/* Reduce the incoherency worries for gen2
-		 * by only allocating a static shadow, at about 2-3x
-		 * performance cost for forcing rendering to uncached memory.
-		 */
-		if (intel->shadow_buffer) {
-			drm_intel_gem_bo_unmap_gtt(intel->shadow_buffer);
-			drm_intel_bo_unreference(intel->shadow_buffer);
-			intel->shadow_buffer = NULL;
-		}
-
-		stride = ALIGN(scrn->virtualX * intel->cpp, 4);
-		size = stride * scrn->virtualY;
-		bo = drm_intel_bo_alloc(intel->bufmgr,
-					"shadow", size,
-					0);
-		if (bo && drm_intel_gem_bo_map_gtt(bo) == 0) {
-			screen->ModifyPixmapHeader(pixmap,
-						   scrn->virtualX,
-						   scrn->virtualY,
-						   -1, -1,
-						   stride,
-						   bo->virtual);
-			intel->shadow_buffer = bo;
-		}
-	} else {
-		void *buffer;
-
-		stride = intel->cpp*scrn->virtualX;
-		buffer = malloc(stride * scrn->virtualY);
-
-		if (buffer && screen->ModifyPixmapHeader(pixmap,
-							 scrn->virtualX,
-							 scrn->virtualY,
-							 -1, -1,
-							 stride,
-							 buffer)) {
-			if (intel->shadow_buffer)
-				free(intel->shadow_buffer);
-
-			intel->shadow_buffer = buffer;
-		} else
-			stride = intel->shadow_stride;
-	}
-
-	if (!intel->shadow_damage) {
-		intel->shadow_damage = DamageCreate(NULL, NULL,
-						    DamageReportNone,
-						    TRUE,
-						    screen,
-						    intel);
-		DamageRegister(&pixmap->drawable, intel->shadow_damage);
-		DamageSetReportAfterOp(intel->shadow_damage, TRUE);
-	}
-
-	scrn->displayWidth = stride / intel->cpp;
-	intel->shadow_stride = stride;
-}
-
 void intel_uxa_block_handler(intel_screen_private *intel)
 {
 	if (intel->shadow_damage &&
@@ -1109,11 +937,6 @@ void intel_uxa_block_handler(intel_screen_private *intel)
 	}
 }
 
-static Bool intel_uxa_pixmap_is_offscreen(PixmapPtr pixmap)
-{
-	return intel_get_pixmap_private(pixmap) != NULL;
-}
-
 static PixmapPtr
 intel_uxa_create_pixmap(ScreenPtr screen, int w, int h, int depth,
 			unsigned usage)
@@ -1128,6 +951,9 @@ intel_uxa_create_pixmap(ScreenPtr screen, int w, int h, int depth,
 	if (depth == 1 || intel->force_fallback)
 		return fbCreatePixmap(screen, w, h, depth, usage);
 
+	if (intel->use_shadow && (usage & INTEL_CREATE_PIXMAP_DRI2) == 0)
+		return fbCreatePixmap(screen, w, h, depth, usage);
+
 	if (usage == CREATE_PIXMAP_USAGE_GLYPH_PICTURE && w <= 32 && h <= 32)
 		return fbCreatePixmap(screen, w, h, depth, usage);
 
@@ -1143,9 +969,9 @@ intel_uxa_create_pixmap(ScreenPtr screen, int w, int h, int depth,
 		 * to be effectively tiled.
 		 */
 		tiling = I915_TILING_X;
-		if (usage == INTEL_CREATE_PIXMAP_TILING_Y)
+		if (usage & INTEL_CREATE_PIXMAP_TILING_Y)
 			tiling = I915_TILING_Y;
-		if (usage == UXA_CREATE_PIXMAP_FOR_MAP || usage == INTEL_CREATE_PIXMAP_TILING_NONE)
+		if (usage == UXA_CREATE_PIXMAP_FOR_MAP || usage & INTEL_CREATE_PIXMAP_TILING_NONE)
 			tiling = I915_TILING_NONE;
 
 		/* if tiling is off force to none */
@@ -1232,6 +1058,7 @@ intel_uxa_create_pixmap(ScreenPtr screen, int w, int h, int depth,
 			drm_intel_bo_set_tiling(priv->bo, &tiling, stride);
 		priv->stride = stride;
 		priv->tiling = tiling;
+		priv->offscreen = 1;
 
 		screen->ModifyPixmapHeader(pixmap, w, h, 0, 0, stride, NULL);
 
@@ -1255,22 +1082,22 @@ void intel_uxa_create_screen_resources(ScreenPtr screen)
 {
 	ScrnInfoPtr scrn = xf86Screens[screen->myNum];
 	intel_screen_private *intel = intel_get_screen_private(scrn);
+	dri_bo *bo = intel->front_buffer;
+
+	drm_intel_gem_bo_map_gtt(bo);
 
 	if (intel->use_shadow) {
 		intel_shadow_create(intel);
 	} else {
-		dri_bo *bo = intel->front_buffer;
-		if (bo != NULL) {
-			PixmapPtr pixmap = screen->GetScreenPixmap(screen);
-			intel_set_pixmap_bo(pixmap, bo);
-			intel_get_pixmap_private(pixmap)->busy = 1;
-			screen->ModifyPixmapHeader(pixmap,
-						   scrn->virtualX,
-						   scrn->virtualY,
-						   -1, -1,
-						   intel->front_pitch,
-						   NULL);
-		}
+		PixmapPtr pixmap = screen->GetScreenPixmap(screen);
+		intel_set_pixmap_bo(pixmap, bo);
+		intel_get_pixmap_private(pixmap)->busy = 1;
+		screen->ModifyPixmapHeader(pixmap,
+					   scrn->virtualX,
+					   scrn->virtualY,
+					   -1, -1,
+					   intel->front_pitch,
+					   NULL);
 		scrn->displayWidth = intel->front_pitch / intel->cpp;
 	}
 }
@@ -1316,7 +1143,7 @@ intel_limits_init(intel_screen_private *intel)
 	 * the front, which will have an appropriate pitch/offset already set up,
 	 * so UXA doesn't need to worry.
 	 */
-	if (IS_I965G(intel)) {
+	if (INTEL_INFO(intel)->gen >= 40) {
 		intel->accel_pixmap_offset_alignment = 4 * 2;
 		intel->accel_max_x = 8192;
 		intel->accel_max_y = 8192;
@@ -1371,7 +1198,7 @@ Bool intel_uxa_init(ScreenPtr screen)
 	intel->uxa_driver->done_copy = i830_uxa_done_copy;
 
 	/* Composite */
-	if (!IS_I9XX(intel)) {
+	if (IS_GEN2(intel)) {
 		intel->uxa_driver->check_composite = i830_check_composite;
 		intel->uxa_driver->check_composite_target = i830_check_composite_target;
 		intel->uxa_driver->check_composite_texture = i830_check_composite_texture;
@@ -1380,8 +1207,7 @@ Bool intel_uxa_init(ScreenPtr screen)
 		intel->uxa_driver->done_composite = i830_done_composite;
 
 		intel->batch_flush_notify = i830_batch_flush_notify;
-	} else if (IS_I915G(intel) || IS_I915GM(intel) ||
-		   IS_I945G(intel) || IS_I945GM(intel) || IS_G33CLASS(intel)) {
+	} else if (IS_GEN3(intel)) {
 		intel->uxa_driver->check_composite = i915_check_composite;
 		intel->uxa_driver->check_composite_target = i915_check_composite_target;
 		intel->uxa_driver->check_composite_texture = i915_check_composite_texture;
@@ -1406,7 +1232,6 @@ Bool intel_uxa_init(ScreenPtr screen)
 	intel->uxa_driver->get_image = intel_uxa_get_image;
 
 	intel->uxa_driver->prepare_access = intel_uxa_prepare_access;
-	intel->uxa_driver->finish_access = intel_uxa_finish_access;
 	intel->uxa_driver->pixmap_is_offscreen = intel_uxa_pixmap_is_offscreen;
 
 	screen->CreatePixmap = intel_uxa_create_pixmap;
diff --git a/src/intel_video.c b/src/intel_video.c
index 9c918d5..5d16778 100644
--- a/src/intel_video.c
+++ b/src/intel_video.c
@@ -363,7 +363,8 @@ void I830InitVideo(ScreenPtr screen)
 	 * supported hardware.
 	 */
 	if (scrn->bitsPerPixel >= 16 &&
-	    (IS_I9XX(intel) || IS_I965G(intel)) &&
+	    INTEL_INFO(intel)->gen >= 30 &&
+	    INTEL_INFO(intel)->gen < 60 &&
 	    !intel->use_shadow) {
 		texturedAdaptor = I830SetupImageVideoTextured(screen);
 		if (texturedAdaptor != NULL) {
@@ -447,7 +448,7 @@ static XF86VideoAdaptorPtr I830SetupImageVideoOverlay(ScreenPtr screen)
 
 	adapt->pPortPrivates[0].ptr = (pointer) (adaptor_priv);
 	adapt->nAttributes = NUM_ATTRIBUTES;
-	if (IS_I9XX(intel))
+	if (INTEL_INFO(intel)->gen >= 30)
 		adapt->nAttributes += GAMMA_ATTRIBUTES;	/* has gamma */
 	adapt->pAttributes =
 	    xnfalloc(sizeof(XF86AttributeRec) * adapt->nAttributes);
@@ -456,7 +457,7 @@ static XF86VideoAdaptorPtr I830SetupImageVideoOverlay(ScreenPtr screen)
 	memcpy((char *)att, (char *)Attributes,
 	       sizeof(XF86AttributeRec) * NUM_ATTRIBUTES);
 	att += NUM_ATTRIBUTES;
-	if (IS_I9XX(intel)) {
+	if (INTEL_INFO(intel)->gen >= 30) {
 		memcpy((char *)att, (char *)GammaAttributes,
 		       sizeof(XF86AttributeRec) * GAMMA_ATTRIBUTES);
 		att += GAMMA_ATTRIBUTES;
@@ -507,7 +508,7 @@ static XF86VideoAdaptorPtr I830SetupImageVideoOverlay(ScreenPtr screen)
 	/* Allow the pipe to be switched from pipe A to B when in clone mode */
 	xvPipe = MAKE_ATOM("XV_PIPE");
 
-	if (IS_I9XX(intel)) {
+	if (INTEL_INFO(intel)->gen >= 30) {
 		xvGamma0 = MAKE_ATOM("XV_GAMMA0");
 		xvGamma1 = MAKE_ATOM("XV_GAMMA1");
 		xvGamma2 = MAKE_ATOM("XV_GAMMA2");
@@ -702,17 +703,17 @@ I830SetPortAttributeOverlay(ScrnInfoPtr scrn,
 			adaptor_priv->desired_crtc = NULL;
 		else
 			adaptor_priv->desired_crtc = xf86_config->crtc[value];
-	} else if (attribute == xvGamma0 && (IS_I9XX(intel))) {
+	} else if (attribute == xvGamma0 && (INTEL_INFO(intel)->gen >= 30)) {
 		adaptor_priv->gamma0 = value;
-	} else if (attribute == xvGamma1 && (IS_I9XX(intel))) {
+	} else if (attribute == xvGamma1 && (INTEL_INFO(intel)->gen >= 30)) {
 		adaptor_priv->gamma1 = value;
-	} else if (attribute == xvGamma2 && (IS_I9XX(intel))) {
+	} else if (attribute == xvGamma2 && (INTEL_INFO(intel)->gen >= 30)) {
 		adaptor_priv->gamma2 = value;
-	} else if (attribute == xvGamma3 && (IS_I9XX(intel))) {
+	} else if (attribute == xvGamma3 && (INTEL_INFO(intel)->gen >= 30)) {
 		adaptor_priv->gamma3 = value;
-	} else if (attribute == xvGamma4 && (IS_I9XX(intel))) {
+	} else if (attribute == xvGamma4 && (INTEL_INFO(intel)->gen >= 30)) {
 		adaptor_priv->gamma4 = value;
-	} else if (attribute == xvGamma5 && (IS_I9XX(intel))) {
+	} else if (attribute == xvGamma5 && (INTEL_INFO(intel)->gen >= 30)) {
 		adaptor_priv->gamma5 = value;
 	} else if (attribute == xvColorKey) {
 		adaptor_priv->colorKey = value;
@@ -725,7 +726,7 @@ I830SetPortAttributeOverlay(ScrnInfoPtr scrn,
 	     attribute == xvGamma2 ||
 	     attribute == xvGamma3 ||
 	     attribute == xvGamma4 ||
-	     attribute == xvGamma5) && (IS_I9XX(intel))) {
+	     attribute == xvGamma5) && (INTEL_INFO(intel)->gen >= 30)) {
 		OVERLAY_DEBUG("GAMMA\n");
 	}
 
@@ -759,17 +760,17 @@ I830GetPortAttribute(ScrnInfoPtr scrn,
 		if (c == xf86_config->num_crtc)
 			c = -1;
 		*value = c;
-	} else if (attribute == xvGamma0 && (IS_I9XX(intel))) {
+	} else if (attribute == xvGamma0 && (INTEL_INFO(intel)->gen >= 30)) {
 		*value = adaptor_priv->gamma0;
-	} else if (attribute == xvGamma1 && (IS_I9XX(intel))) {
+	} else if (attribute == xvGamma1 && (INTEL_INFO(intel)->gen >= 30)) {
 		*value = adaptor_priv->gamma1;
-	} else if (attribute == xvGamma2 && (IS_I9XX(intel))) {
+	} else if (attribute == xvGamma2 && (INTEL_INFO(intel)->gen >= 30)) {
 		*value = adaptor_priv->gamma2;
-	} else if (attribute == xvGamma3 && (IS_I9XX(intel))) {
+	} else if (attribute == xvGamma3 && (INTEL_INFO(intel)->gen >= 30)) {
 		*value = adaptor_priv->gamma3;
-	} else if (attribute == xvGamma4 && (IS_I9XX(intel))) {
+	} else if (attribute == xvGamma4 && (INTEL_INFO(intel)->gen >= 30)) {
 		*value = adaptor_priv->gamma4;
-	} else if (attribute == xvGamma5 && (IS_I9XX(intel))) {
+	} else if (attribute == xvGamma5 && (INTEL_INFO(intel)->gen >= 30)) {
 		*value = adaptor_priv->gamma5;
 	} else if (attribute == xvColorKey) {
 		*value = adaptor_priv->colorKey;
@@ -1333,18 +1334,18 @@ intel_wait_for_scanline(ScrnInfoPtr scrn, PixmapPtr pixmap,
 	 * of extra time for the blitter to start up and
 	 * do its job for a full height blit
 	 */
-	if (full_height && !IS_I965G(intel))
+	if (full_height && INTEL_INFO(intel)->gen < 40)
 		y2 -= 2;
 
 	if (pipe == 0) {
 		pipe = MI_LOAD_SCAN_LINES_DISPLAY_PIPEA;
 		event = MI_WAIT_FOR_PIPEA_SCAN_LINE_WINDOW;
-		if (full_height && IS_I965G(intel))
+		if (full_height && INTEL_INFO(intel)->gen >= 40)
 			event = MI_WAIT_FOR_PIPEA_SVBLANK;
 	} else {
 		pipe = MI_LOAD_SCAN_LINES_DISPLAY_PIPEB;
 		event = MI_WAIT_FOR_PIPEB_SCAN_LINE_WINDOW;
-		if (full_height && IS_I965G(intel))
+		if (full_height && INTEL_INFO(intel)->gen >= 40)
 			event = MI_WAIT_FOR_PIPEB_SVBLANK;
 	}
 
@@ -1401,7 +1402,7 @@ intel_setup_dst_params(ScrnInfoPtr scrn, intel_adaptor_private *adaptor_priv, sh
 	if (adaptor_priv->textured) {
 		pitchAlign = 4;
 	} else {
-		if (IS_I965G(intel))
+		if (INTEL_INFO(intel)->gen >= 40)
 			/* Actually the alignment is 64 bytes, too. But the
 			 * stride must be at least 512 bytes. Take the easy fix
 			 * and align on 512 bytes unconditionally. */
@@ -1417,7 +1418,7 @@ intel_setup_dst_params(ScrnInfoPtr scrn, intel_adaptor_private *adaptor_priv, sh
 
 #if INTEL_XVMC
 	/* for i915 xvmc, hw requires 1kb aligned surfaces */
-	if ((id == FOURCC_XVMC) && IS_I915(intel))
+	if ((id == FOURCC_XVMC) && IS_GEN3(intel))
 		pitchAlign = 1024;
 #endif
 
@@ -1582,7 +1583,7 @@ I830PutImageTextured(ScrnInfoPtr scrn,
 		intel_wait_for_scanline(scrn, pixmap, crtc, clipBoxes);
 	}
 
-	if (IS_I965G(intel)) {
+	if (INTEL_INFO(intel)->gen >= 40) {
 		I965DisplayVideoTextured(scrn, adaptor_priv, id, clipBoxes,
 					 width, height, dstPitch, dstPitch2,
 					 src_w, src_h,
diff --git a/src/legacy/i810/i810.h b/src/legacy/i810/i810.h
index b39cfff..6620695 100644
--- a/src/legacy/i810/i810.h
+++ b/src/legacy/i810/i810.h
@@ -57,7 +57,6 @@ SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "sarea.h"
 #define _XF86DRI_SERVER_
 #include "dri.h"
-#include "GL/glxint.h"
 #include "i810_dri.h"
 #endif
 
@@ -230,8 +229,6 @@ typedef struct _I810Rec {
    DRIInfoPtr pDRIInfo;
    int drmSubFD;
    int numVisualConfigs;
-   __GLXvisualConfig *pVisualConfigs;
-   I810ConfigPrivPtr pVisualConfigsPriv;
    unsigned long dcacheHandle;
    unsigned long backHandle;
    unsigned long zHandle;
diff --git a/src/legacy/i810/i810_dri.c b/src/legacy/i810/i810_dri.c
index 3326c37..509c141 100644
--- a/src/legacy/i810/i810_dri.c
+++ b/src/legacy/i810/i810_dri.c
@@ -938,10 +938,6 @@ I810DRICloseScreen(ScreenPtr pScreen)
       DRIDestroyInfoRec(pI810->pDRIInfo);
       pI810->pDRIInfo = NULL;
    }
-   if (pI810->pVisualConfigs)
-      free(pI810->pVisualConfigs);
-   if (pI810->pVisualConfigsPriv)
-      free(pI810->pVisualConfigsPriv);
 }
 
 static Bool
diff --git a/uxa/uxa-glyphs.c b/uxa/uxa-glyphs.c
index ad4f387..420e891 100644
--- a/uxa/uxa-glyphs.c
+++ b/uxa/uxa-glyphs.c
@@ -164,7 +164,12 @@ static Bool uxa_realize_glyph_caches(ScreenPtr pScreen)
 					       INTEL_CREATE_PIXMAP_TILING_X);
 		if (!pixmap)
 			goto bail;
-		assert (uxa_pixmap_is_offscreen(pixmap));
+		if (!uxa_pixmap_is_offscreen(pixmap)) {
+			/* Presume shadow is in-effect */
+			pScreen->DestroyPixmap(pixmap);
+			uxa_unrealize_glyph_caches(pScreen);
+			return TRUE;
+		}
 
 		component_alpha = NeedsComponent(pPictFormat->format);
 		picture = CreatePicture(0, &pixmap->drawable, pPictFormat,
diff --git a/uxa/uxa.c b/uxa/uxa.c
index 3c81a85..856a0ce 100644
--- a/uxa/uxa.c
+++ b/uxa/uxa.c
@@ -164,11 +164,12 @@ void uxa_finish_access(DrawablePtr pDrawable)
 {
 	ScreenPtr pScreen = pDrawable->pScreen;
 	uxa_screen_t *uxa_screen = uxa_get_screen(pScreen);
-	PixmapPtr pPixmap = uxa_get_drawable_pixmap(pDrawable);
+	PixmapPtr pPixmap;
 
 	if (uxa_screen->info->finish_access == NULL)
 		return;
 
+	pPixmap = uxa_get_drawable_pixmap(pDrawable);
 	if (!uxa_pixmap_is_offscreen(pPixmap))
 		return;
 
